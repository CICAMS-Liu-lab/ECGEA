#!/usr/bin/R
# created by Jiawei Wang
# revised by Lixing Qi at 02.Apr.2018

options(bitmapType='cairo')
library(ggplot2)
library(reshape2)
library(plyr)
library(scales)

## To ensure the script be used in different situations and more robust, 
## we just adopted a "silly" approach to pass the arguments: we explicitly list all the input files in arguments.
## And in actual implementation, the argument list are generated by a main program automatically.
# args <- c("input/WGC053180R_RNA_metrics.tsv", # the output tsv from collectRNAseqMetrics
#           "input/WGC053181R_RNA_metrics.tsv",
#           "input/WGC053182R_RNA_metrics.tsv",
#           "input/WGC053183R_RNA_metrics.tsv",
#           "input/WGC053184R_RNA_metrics.tsv",
#           "input/WGC053185R_RNA_metrics.tsv",
#           "input/WGC053180R_alignment_metrics.tsv", # the output tsv from collectAlignmentMetrics
#           "input/WGC053181R_alignment_metrics.tsv",
#           "input/WGC053182R_alignment_metrics.tsv",
#           "input/WGC053183R_alignment_metrics.tsv",
#           "input/WGC053184R_alignment_metrics.tsv",
#           "input/WGC053185R_alignment_metrics.tsv"
#           )
args <- commandArgs(TRUE)
if(length(args)==0){
  cat("Usage: Rscript WGC013024R_bamQC.tsv WGC013025R_bamQC.tsv WGC013024R_alignment_metrics.tsv WGC013025R_alignment_metrics.tsv [...]" )
}
### extract collect rna-seq metrics results
#nsample <- length(args)/3
nsample <- length(args)/2
rnaseq.qc.clean <- data.frame()
for (rnaseq_metrics in args[1:nsample]){
  sample <- unlist(strsplit(basename(rnaseq_metrics), "_"))[1]
  rnaseq.qc <- read.table(rnaseq_metrics, sep = "\t",check.names = F, nrows=2)
  rec <- rnaseq.qc[2, c(1,2,3,4,5,6,7,11,12,13,14,15,16,22)]
  rownames(rec) <- sample
  rnaseq.qc.clean <- rbind(rnaseq.qc.clean, rec)
}
colnames(rnaseq.qc.clean) <- c("Total_bases", "Aligned_bases", "Ribosomal_bases", "Coding_bases", "UTR_bases", "Intronic_bases", "Intergenic_bases",
                               "Ribosomal_bases(%)", "Coding_bases(%)", "UTR_bases(%)", "Intronic_bases(%)", "Intergenic_bases(%)", "mRNA_bases(%)", "5Prime3Prime_bias")


### extract collect alignment metrics results
mapping.qc.clean <- data.frame()
for (mapping_metrics in args[(1+nsample):(nsample*2)]){
  sample <- unlist(strsplit(basename(mapping_metrics), "_"))[1]
  mapping.qc <- read.table(mapping_metrics, sep="\t", header=T,check.names = F)
  if (mapping.qc[1,1]=="FIRST_OF_PAIR"){
  	rec <- mapping.qc[3, c(3,6,7,8,16,22)]}
  else{
  	rec <- mapping.qc[1, c(3,6,7,8,16,22)]}
  rownames(rec) <- sample
  mapping.qc.clean <- rbind(mapping.qc.clean, rec)
}
colnames(mapping.qc.clean) <- c("Clean_reads", "Aligned_reads", "Aligned_reads(%)", "Aligned_bases", "Read_length", "Adapter_pct")

### extract adapter ratio 
#adapter.qc.clean <- data.frame()
#for (adapter_ratio in args[(1+(nsample*2)):(nsample*3)]){
#  sample <- unlist(strsplit(basename(adapter_ratio), "_"))[1]
#  adapter.qc <- read.table(adapter_ratio)
#  read_adapter_ratio <- round(adapter.qc[2,2]/adapter.qc[1,2],4)
#  base_adapter_ratio <- round(adapter.qc[3,2]/(adapter.qc[1,2]*150), 4)
#  rec = data.frame("Read_adapter(%)"=read_adapter_ratio,
#                   "Base_adapter(%)"=base_adapter_ratio)
#  rownames(rec) <- sample
#  colnames(rec) <- c("Adapter_reads(%)", "Adapter_bases(%)")
#  adapter.qc.clean  <- rbind(adapter.qc.clean , rec)
#}

### merge above two results into one table in proper order
qctable <- cbind(mapping.qc.clean[,c(1,2,3)],
                 "Read_length_mean" = mapping.qc.clean$Read_length,
                 "Total_bases" = rnaseq.qc.clean$Total_bases,
                 "Aligned_bases" = mapping.qc.clean$Aligned_bases,
                 "Aligned_bases(%)" = mapping.qc.clean$Aligned_bases/as.numeric(as.character(rnaseq.qc.clean$Total_bases)),
                 rnaseq.qc.clean[,c(3,8,4,9,5,10,6,11,7,12,13,14)])

qctable.names <- colnames(qctable)
qctable.out <- data.frame(t(qctable),stringsAsFactors=F)
qctable.out <- rbind(Sample=colnames(qctable.out), qctable.out)

write.table(qctable.out, "RNA-seq_QCtable.xls", sep="\t", col.names = F)

### feature ratio plot
#feature.ratio <- data.frame(t(qctable[,c( 10, 12,14, 16, 8, 6, 5)]), stringsAsFactors = F, check.names = F)
feature.ratio <- data.frame(t(qctable[,c( 11, 13,15, 17, 9)]), stringsAsFactors = F, check.names = F)

dm <- data.matrix(feature.ratio)
dm[4,] <- dm[4,]+dm[5,]
dm=dm[1:4,]
rownames(dm)= c("Coding", "UTR", "Intronic", "Intergenic+Ribosomal")
feature.ratio=data.frame(dm)
#dm[5,] <- dm[7,]-dm[6,] #unmapped bases

#rownames(dm)[6] <- "Unmapped_bases"
#feature.ratio <- data.frame(prop.table(dm[1:5,], margin=2))

n_cnt <- 1
n_img <- ceiling(nsample/10)
n_bat <- ceiling(nsample/n_img)


for (i in 1:nsample){
  rnk=i%%n_bat
  if(rnk==1)
  {
    if ((i+n_bat-1)>nsample){
      j <- nsample
    }else
    {
      j <- i+n_bat-1
    }
    feature.ratio.sub <- feature.ratio[,i:j]
    #feature.ratio.sub$Feature <- c("Coding", "UTR", "Intronic", "Intergenic+Ribosomal", "Unmapped")
    feature.ratio.sub$Feature <- c("Coding", "UTR", "Intronic", "Intergenic+Ribosomal")
    feature.ratio.long <- melt(feature.ratio.sub, id.vars = "Feature")
    feature.ratio.long <- ddply(feature.ratio.long, .(variable), 
                  transform, pos = cumsum(value) - (0.5 * value)
    )
    feature.ratio.long$pct <- paste0(round(feature.ratio.long$value*100,1),"%")
    
    attach(feature.ratio.long)
    ggplot(feature.ratio.long, aes(x=variable, y=value, fill=Feature, group=factor(1)))+
      geom_bar(stat = "identity", position = "stack")+
      geom_text(aes(label = pct, y = pos))+
      xlab("")+
      ylab("")+
      scale_y_continuous(labels=percent)+
      theme(axis.text.x = element_text(face="bold", size=14, angle=45, hjust = 1),
            axis.text.y = element_text(face="bold", size=14))
      if(nsample<=n_bat){
        ggsave(paste0("RNA-seq_alignment_feature.pdf"),width=10,height=10)
        ggsave(paste0("RNA-seq_alignment_feature.png"),width=10,height=10)

        }else{
        ggsave(paste0("RNA-seq_alignment_feature.", n_cnt,".pdf"),width=10,height=10)
        ggsave(paste0("RNA-seq_alignment_feature.", n_cnt,".png"),width=10,height=10)
        }
      #ggsave(paste0("RNA-seq_alignment_feature.", n_cnt,".png"),width=10,height=10)
      n_cnt = n_cnt + 1
      
    detach(feature.ratio.long)
    
  }
}

# covearge plot
coverage <- do.call("cbind", lapply(args[1:nsample], function(fn){
                      data.frame(read.table(fn, sep="\t", skip=9, check.names = F,header=T))[,2]}))
colnames(coverage) <- sapply(args[1:nsample], function(x){unlist(strsplit(basename(x), split="_"))[1]})
n_cnt <- 1
n_img <- ceiling(nsample/10)
n_bat <- ceiling(nsample/n_img)
for (i in 1:nsample){
  rnk=i%%n_bat
  if(rnk==1)
  {
    if ((i+n_bat-1)>nsample){
      j = nsample
    }else
    {
      j = i+n_bat-1
    }
    coverage_long <- melt(coverage[,i:j])
    ggplot(coverage_long, aes(coverage_long$Var1, coverage_long$value, colour=coverage_long$Var2))+
      scale_colour_manual(values = rainbow(n_bat))+
      geom_hline(yintercept = 1, size=1, linetype="dashed", colour="darkgrey")+
      geom_line()+
      ylab("Normalized Coverage") +
      xlab("Normalized distance along transcript(5'->3')") +
      theme(legend.title = element_blank())
    if(nsample<=n_bat){
        ggsave("RNA-seq_alignment_coverage.pdf",width=10,height=6)
        ggsave("RNA-seq_alignment_coverage.png",width=10,height=6)

      }else{
      ggsave(paste0("RNA-seq_alignment_coverage.", n_cnt,".pdf"),width=10,height=6)
      ggsave(paste0("RNA-seq_alignment_coverage.", n_cnt,".png"),width=10,height=6)

      }
    #ggsave(paste0("RNA-seq_alignment_coverage.", n_cnt,".png"),width=10,height=6)
    n_cnt = n_cnt + 1
  }
}

